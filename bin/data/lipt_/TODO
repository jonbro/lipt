- edge to edge slide to switch screens
- add a playhead indicator
x note editor (up down note, left right octave)
- two byte editor (FFFF)
- effect editor (pulls from array of different effect types)
x one byte editor
- one byte editor, fix hori - 16 edit
- edit clear
- nonedit, one byte for line display
- chain editor
- song editor
- instrument editor
- synth implementation
- physicfs
- sample loading
- load some samples by default
- saving

structure
- root. contains the core bpm, and name of the project. This is how the samples are looked up.
- channels. contain a list of chains, and also contain a reference to a synth.
			These are the synthesizers. They can play one sample ocilator at a time.
			contains the current executing groove for the channel.

- instruments. contains the default settings for the instrument, the sample reference and name.

audio engine

- parameters
channels // the synthesizers
songStep // where in the song each channel is
currentChain // the currently playing chain for each channel... incase things get deleted while playing
chainStep // where in the chain each channel is
currentPhrase // the currently playing phrase in the channel
phraseStep // where in the phrase the channel is

- functions
tick() // moves everything forward one step
start() // kills all the channels
stop()


from lua, I should do something like this

player = Player()
song = Song() 				-- contains all of the song data. This is a more lua-y object
song:setChain(0, 0, 0)   	-- sets a channel position to a chain
chain = song:getChain(0) 	-- gets a chain
chain:set(0, 0, 0)			-- set chain to phrase and transpose at position

sample = SampleData()
sample:loadSample(blud.doc_root .. "/test/test.wav")
instrument = song:getInstrument(0)
instrument:setSample(sample)

phrase = song:getPhrase(0)	-- get the phrase
phrase:set(0, 0)			-- set the note, instrument, and effects (to come)

player:loadSong(song)
